---
title: Building Tools
description: Implement Python backends that power FastApps widgets and expose inputs to ChatGPT.
---

Learn how to create Python tools that power your ChatGPT widgets.

## What is a Tool?

A tool is a Python class that:
- Lives in `server/tools/<widget>_tool.py`
- Extends `BaseWidget`
- Defines inputs with Pydantic
- Implements widget logic in `execute()`

## Core Concepts

### BaseWidget

`BaseWidget` is the **abstract base class** that all FastApps widgets must inherit from. It handles all the MCP (Model Context Protocol) wiring and widget lifecycle management automatically.

#### Required Class Attributes

| Attribute | Type | Description | Example |
|-----------|------|-------------|---------|
| `identifier` | `str` | Unique widget identifier. Must match the widget folder name in `widgets/`. Used as the resource URI identifier | `"greeting"` for `widgets/greeting/` |
| `title` | `str` | Human-readable tool name displayed in ChatGPT interface. Shown when the model considers calling this tool | `"Show Greeting Widget"` |
| `input_schema` | `Type[BaseModel]` | Pydantic model defining the tool's input parameters. ChatGPT uses this JSON schema to understand when and how to call your tool | `GreetingInput` |
| `invoking` | `str` | Short, localized status message shown to users **while** the tool is being executed. Maps to `openai/toolInvocation/invoking` | `"Preparing your greeting…"` |
| `invoked` | `str` | Short, localized status message shown to users **after** the tool completes. Maps to `openai/toolInvocation/invoked` | `"Greeting ready!"` |

#### Optional Class Attributes

| Attribute | Type | Default | Description |
|-----------|------|---------|-------------|
| `description` | `str` | `""` | Tool description that helps the model understand when to use this tool |
| `widget_accessible` | `bool` | `True` | Whether the component can initiate tool calls back to the server. Set to `true` to allow component-initiated tool access. Maps to `openai/widgetAccessible` |
| `widget_description` | `Optional[str]` | `None` | Description shown **to the model** when the component is rendered. Helps the model understand what's being displayed to avoid redundant content in its response. Maps to `openai/widgetDescription`. Example: `"Renders an interactive calendar showing the user's appointments"` |
| `widget_csp` | `Optional[Dict[str, List[str]]]` | `None` | **Content Security Policy** defining which domains your component can access. Required for production distribution. Format: `{"connect_domains": [...], "resource_domains": [...]}`. See below for details |
| `widget_prefers_border` | `bool` | `False` | Whether ChatGPT should render a border around the widget for a "Card" layout. Maps to `openai/widgetPrefersBorder` |
| `read_only` | `bool` | `True` | Hint that this tool is read-only and doesn't modify server state. Used for optimization and UX |

**Content Security Policy (`widget_csp`) Details:**

The CSP controls which external resources your component can access. It defines two arrays:

```python
widget_csp = {
    "connect_domains": [
        "https://api.example.com",      # Domains for fetch/API calls (connect-src)
        "https://analytics.example.com"
    ],
    "resource_domains": [
        "https://cdn.example.com",      # Domains for images, fonts, stylesheets
        "https://fonts.googleapis.com"  # (script-src, img-src, font-src)
    ]
}
```

These map to the following CSP directives:
- `script-src 'self' ${resource_domains}`
- `img-src 'self' data: ${resource_domains}`
- `font-src 'self' ${resource_domains}`
- `connect-src 'self' ${connect_domains}`

**Important:** A strict CSP is required for broad distribution in ChatGPT and will be inspected during the MCP review process.

#### Required Method

**`async execute(input_data: BaseModel) -> Dict[str, Any]`**

This is the core method where you implement your tool's logic and return data to hydrate your component.

**Parameters:**
- `input_data`: An instance of your `input_schema` with validated parameters from ChatGPT

**Returns:**
A dictionary that is injected into your component as `window.openai.toolOutput`. This data:
- **Hydrates your React component** with the information it needs to render
- **Is visible to the ChatGPT model**, which can narrate or summarize the values
- Should be **JSON-serializable** (strings, numbers, booleans, lists, dicts)
- Should be **scoped to what your UI needs** – keep it concise for better model performance

**Must be async:**
Always use `async def` even if you don't have any `await` calls inside.

**Example:**
```python
async def execute(self, input_data: MyInput) -> Dict[str, Any]:
    # Fetch data from your backend/API
    result = await some_async_operation()
    
    # Return structured data for your component
    return {
        "message": "Success!",
        "data": result,
        "timestamp": datetime.now().isoformat()
    }
```

**Important:** The returned dictionary is passed to your React component via `useWidgetProps()` and is also visible to the ChatGPT model.

### ConfigDict

`ConfigDict` is a **Pydantic configuration helper** used to configure how your input models behave. In FastApps, it's essential for handling field name conversions between Python (snake_case) and JavaScript/ChatGPT (camelCase).

#### Why You Need It

When you define a Pydantic model for your widget inputs, you should always include:

```python
class MyInput(BaseModel):
    model_config = ConfigDict(populate_by_name=True)
```

The `populate_by_name=True` setting allows the model to accept fields by **both** their original name and their alias. This is crucial for interoperability between:
- Python backend (snake_case: `user_name`)
- JavaScript frontend (camelCase: `userName`)

#### Example with Field Aliases

```python
from fastapps import BaseWidget, Field, ConfigDict
from pydantic import BaseModel

class UserInput(BaseModel):
    model_config = ConfigDict(populate_by_name=True)
    
    # Python uses snake_case, ChatGPT sends camelCase
    user_name: str = Field(default="", alias="userName")
    first_name: str = Field(default="", alias="firstName")
    email_address: str = Field(default="", alias="emailAddress")
```

With this configuration:
- ChatGPT can send `{"userName": "john", "firstName": "John"}`
- Python receives it as `input_data.user_name` and `input_data.first_name`

## Basic Tool Structure

```python
from fastapps import BaseWidget, Field, ConfigDict
from pydantic import BaseModel
from typing import Dict, Any

# 1. Define inputs
class GreetingInput(BaseModel):
    model_config = ConfigDict(populate_by_name=True)
    name: str = Field(..., description="Person to greet")

# 2. Implement tool
class GreetingTool(BaseWidget):
    identifier = "greeting"
    title = "Greeting Widget"
    input_schema = GreetingInput
    invoking = "Preparing greeting..."
    invoked = "Greeting ready!"
    
    widget_csp = {
        "connect_domains": [],
        "resource_domains": []
    }

    async def execute(self, input_data: GreetingInput) -> Dict[str, Any]:
        return {"message": f"Hello {input_data.name}!"}
```

## Input Validation

- Use `pydantic` models for automatic validation
- Add descriptions to drive ChatGPT prompt suggestions
- Provide defaults for optional fields

## Accessing External Services

When your widget needs to call external APIs, make sure to:
1. Include the API domain in `widget_csp["connect_domains"]`
2. Use `async`/`await` for network requests
3. Handle errors gracefully

```python
import httpx
from pydantic import BaseModel

class WeatherInput(BaseModel):
    model_config = ConfigDict(populate_by_name=True)
    city: str = Field(..., description="City name")

class WeatherTool(BaseWidget):
    identifier = "weather"
    title = "Weather Widget"
    input_schema = WeatherInput
    invoking = "Fetching weather data..."
    invoked = "Weather data ready!"
    
    # Allow API access
    widget_csp = {
        "connect_domains": ["https://api.weatherapi.com"],
        "resource_domains": []
    }

    async def execute(self, input_data: WeatherInput) -> Dict[str, Any]:
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://api.weatherapi.com/v1/current.json",
                    params={"q": input_data.city, "key": "YOUR_API_KEY"},
                )
                response.raise_for_status()
            data = response.json()
            return {
                "city": input_data.city,
                "temperature": data["current"]["temp_c"],
                "condition": data["current"]["condition"]["text"]
            }
        except Exception as e:
            return {
                "error": str(e),
                "city": input_data.city
            }
```

## Returning Data

- Return dictionaries that match the props your widget expects
- Stick to JSON-serializable data types
- Provide friendly defaults (`[]`, `{}`, etc.) when data is missing

## Complete Example

Here's a full example showing all the features of `BaseWidget` and `ConfigDict`:

```python
from fastapps import BaseWidget, Field, ConfigDict
from pydantic import BaseModel
from typing import Dict, Any, Optional
import httpx

class GitHubRepoInput(BaseModel):
    """Input schema with validation and field aliases"""
    model_config = ConfigDict(populate_by_name=True)
    
    repo_name: str = Field(
        ...,
        alias="repoName",
        description="GitHub repository in format: owner/repo",
        pattern=r"^[\w-]+/[\w-]+$"
    )
    include_stats: bool = Field(
        default=True,
        alias="includeStats",
        description="Include repository statistics"
    )

class GitHubRepoTool(BaseWidget):
    """Widget that fetches GitHub repository information"""
    
    # Required attributes
    identifier = "github_repo"
    title = "Show GitHub Repository"
    input_schema = GitHubRepoInput
    description = "Displays detailed information about a GitHub repository including stats, description, and metadata"
    invoking = "Fetching repository data…"
    invoked = "Repository loaded"
    
    # Optional attributes
    widget_accessible = False  # Set to True only if component needs to call tools
    widget_description = "Renders an interactive card showing GitHub repository information including name, description, stars, forks, and programming language"
    widget_prefers_border = True  # Renders better as a card
    read_only = True  # This tool doesn't modify server state
    
    # Content Security Policy
    widget_csp = {
        "connect_domains": [
            "https://api.github.com",
            "https://github.com"
        ],
        "resource_domains": [
            "https://avatars.githubusercontent.com"  # For profile images
        ]
    }
    
    async def execute(self, input_data: GitHubRepoInput) -> Dict[str, Any]:
        """
        Fetch repository data from GitHub API
        
        Returns:
            Dict containing repository information for the React component
        """
        try:
            # Make API request
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"https://api.github.com/repos/{input_data.repo_name}",
                    headers={"Accept": "application/vnd.github.v3+json"}
                )
                response.raise_for_status()
            
            repo_data = response.json()
            
            # Prepare response data
            result = {
                "success": True,
                "name": repo_data["name"],
                "full_name": repo_data["full_name"],
                "description": repo_data.get("description", "No description"),
                "owner": {
                    "name": repo_data["owner"]["login"],
                    "avatar": repo_data["owner"]["avatar_url"]
                },
                "url": repo_data["html_url"],
                "homepage": repo_data.get("homepage", ""),
                "language": repo_data.get("language", "Unknown"),
            }
            
            # Include stats if requested
            if input_data.include_stats:
                result["stats"] = {
                    "stars": repo_data["stargazers_count"],
                    "forks": repo_data["forks_count"],
                    "watchers": repo_data["watchers_count"],
                    "open_issues": repo_data["open_issues_count"],
                    "created_at": repo_data["created_at"],
                    "updated_at": repo_data["updated_at"],
                }
            
            return result
            
        except httpx.HTTPStatusError as e:
            # Handle HTTP errors
            return {
                "success": False,
                "error": f"GitHub API error: {e.response.status_code}",
                "message": "Repository not found or API rate limit exceeded"
            }
        except Exception as e:
            # Handle other errors
            return {
                "success": False,
                "error": str(e),
                "message": "Failed to fetch repository data"
            }
```

This example demonstrates:
- ✅ Complete `BaseWidget` implementation with all attributes
- ✅ `ConfigDict` with `populate_by_name=True` for field alias support
- ✅ Field validation with patterns and descriptions
- ✅ Content Security Policy for API and image access
- ✅ Async/await for external API calls
- ✅ Comprehensive error handling
- ✅ Conditional data based on input parameters
- ✅ Type hints for better IDE support

## Best Practices

**Structure & Organization:**
- Keep business logic in the tool; keep React widgets focused on presentation
- Extract API clients or reusable logic into `server/api/`
- Use descriptive class and variable names

**Async & Performance:**
- Always use `async def` for the `execute()` method
- Use `async`/`await` when calling network resources
- Consider caching for expensive operations

**Error Handling:**
- Always wrap external API calls in try/except blocks
- Return error information to the widget (don't raise exceptions)
- Provide friendly error messages for users
- Log errors for debugging

**Input Validation:**
- Use Pydantic Field constraints (pattern, ge, le, etc.)
- Always include `ConfigDict(populate_by_name=True)` in your input models
- Provide clear descriptions for all fields to help ChatGPT understand when to use your tool
- Use meaningful field aliases for camelCase compatibility

**Security:**
- **Always specify `widget_csp`** with only the domains you need
- A strict CSP is required for production distribution and will be inspected during MCP review
- Never hardcode API keys (use environment variables)
- Validate and sanitize all user inputs
- Be conservative with `connect_domains` and `resource_domains` – only include necessary domains

**Data Return:**
- Return dictionaries scoped to what your UI needs – keep payloads concise
- Remember: the data is **visible to the ChatGPT model**, which may narrate it
- Use `widget_description` to tell the model what's being displayed, reducing redundant responses
- Stick to JSON-serializable data types (str, int, float, bool, list, dict)
- Provide sensible defaults (`[]`, `{}`, `""`) when data is missing
- Include success/error flags for better error handling in the UI

**Status Messages:**
- Keep `invoking` and `invoked` messages short and user-friendly
- Use present progressive for `invoking`: "Fetching data…", "Loading board…"
- Use past tense or present for `invoked`: "Data ready!", "Board loaded"

**Widget Behavior:**
- Set `widget_accessible=True` only if your component needs to initiate tool calls
- Use `widget_description` to help the model understand what's displayed
- Set `widget_prefers_border=True` for components that work better in a "Card" layout
- Mark tools as `read_only=True` if they don't modify server state
