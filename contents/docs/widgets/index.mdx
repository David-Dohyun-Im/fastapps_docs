---
title: Building Widgets
description: Create interactive React components that render FastApps data inside ChatGPT.
---

Learn how to create beautiful, interactive React components for your ChatGPT widgets.

## What is a Widget?

A widget is a React component that:
- Lives in `widgets/<widget-name>/index.jsx`
- Receives props from your Python tool
- Renders in the ChatGPT interface
- Can be interactive and stateful

## Basic Widget Structure

```jsx
import React from "react";
import { useWidgetProps } from "fastapps";

export default function MyWidget() {
  // 1. Get data from Python backend
  const props = useWidgetProps();

  // 2. Render UI based on props
  return (
    <div style={{ padding: "1rem" }}>
      <h2>{props.title}</h2>
      <p>{props.description}</p>
    </div>
  );
}
```

## Pattern: Lists

```jsx
export default function PizzaList() {
  const { pizzas } = useWidgetProps();

  return (
    <ul>
      {pizzas.map((pizza) => (
        <li key={pizza.name}>
          <strong>{pizza.name}</strong> ‚Äî {pizza.style}
        </li>
      ))}
    </ul>
  );
}
```

## Pattern: User Input

```jsx
import { useWidgetState } from "fastapps";

export default function TodoWidget() {
  const [todos, setTodos] = useWidgetState("todos", []);
  const [text, setText] = useWidgetState("text", "");

  return (
    <div>
      <input
        value={text}
        onChange={(event) => setText(event.target.value)}
        placeholder="Add a task"
      />
      <button
        onClick={() => {
          setTodos([...todos, text]);
          setText("");
        }}
      >
        Add
      </button>
      <ul>
        {todos.map((todo) => (
          <li key={todo}>{todo}</li>
        ))}
      </ul>
    </div>
  );
}
```

## Pattern: Conditional UI

```jsx
export default function WeatherWidget() {
  const { loading, weather } = useWidgetProps();

  if (loading) {
    return <p>Loading...</p>;
  }

  if (!weather) {
    return <p>No forecast available.</p>;
  }

  return (
    <div>
      <h2>{weather.city}</h2>
      <p>{weather.summary}</p>
    </div>
  );
}
```

## React Hooks API

### useWidgetProps()

Access data returned from your Python tool's `execute()` method.

```tsx
import { useWidgetProps } from 'fastapps';

interface MyWidgetProps {
  message: string;
  count: number;
  items: string[];
}

export default function MyWidget() {
  const props = useWidgetProps<MyWidgetProps>();
  
  return (
    <div>
      <h1>{props.message}</h1>
      <p>Count: {props.count}</p>
      <ul>
        {props.items.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```

**How it works:**
- Maps to `window.openai.toolOutput`
- Data comes from your Python tool's `return` statement
- Updates automatically on new tool calls

---

### useWidgetState()

Manage persistent state that survives across ChatGPT sessions.

```tsx
import { useWidgetState } from 'fastapps';

export default function Counter() {
  const [state, setState] = useWidgetState({ count: 0 });
  
  const increment = () => {
    setState({ count: state.count + 1 });
  };
  
  return (
    <div>
      <p>Count: {state?.count || 0}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

**How it works:**
- Maps to `window.openai.widgetState` and `setWidgetState()`
- State persists in ChatGPT's conversation context
- Survives page refreshes and widget re-renders
- Accepts initial state as default value

**Advanced usage:**
```tsx
// With TypeScript
interface CounterState {
  count: number;
  lastUpdated: string;
}

const [state, setState] = useWidgetState<CounterState>({
  count: 0,
  lastUpdated: new Date().toISOString()
});

// Update state
setState({
  count: state.count + 1,
  lastUpdated: new Date().toISOString()
});
```

---

### useOpenAiGlobal()

Access ChatGPT environment information like theme, layout, and locale. This is the base hook for accessing any global property.

```tsx
import { useOpenAiGlobal } from 'fastapps';

export default function ThemedWidget() {
  const theme = useOpenAiGlobal('theme');
  const displayMode = useOpenAiGlobal('displayMode');
  const locale = useOpenAiGlobal('locale');
  const maxHeight = useOpenAiGlobal('maxHeight');
  
  return (
    <div style={{
      background: theme === 'dark' ? '#1a1a1a' : '#ffffff',
      color: theme === 'dark' ? '#ffffff' : '#000000',
      maxHeight: `${maxHeight}px`,
      overflow: 'auto'
    }}>
      <p>Current theme: {theme}</p>
      <p>Display mode: {displayMode}</p>
      <p>User locale: {locale}</p>
    </div>
  );
}
```

---

### useDisplayMode()

Convenience hook for accessing the current display mode. Equivalent to `useOpenAiGlobal('displayMode')`.

```tsx
import { useDisplayMode } from 'fastapps';

export default function ResponsiveWidget() {
  const displayMode = useDisplayMode();
  
  return (
    <div className={`mode-${displayMode}`}>
      {displayMode === 'fullscreen' ? (
        <div>
          <h1>Full Screen Layout</h1>
          <p>More space to show detailed content</p>
        </div>
      ) : displayMode === 'pip' ? (
        <div>
          <p>Picture-in-Picture view</p>
        </div>
      ) : (
        <div>
          <p>Inline compact view</p>
        </div>
      )}
    </div>
  );
}
```

**Display modes:**
- `inline` - Default mode, widget appears inline with the conversation
- `pip` - Picture-in-picture mode (mobile may coerce to fullscreen)
- `fullscreen` - Full screen takeover

---

### useMaxHeight()

Convenience hook for accessing the maximum height constraint. Equivalent to `useOpenAiGlobal('maxHeight')`.

```tsx
import { useMaxHeight } from 'fastapps';

export default function ScrollableWidget() {
  const maxHeight = useMaxHeight();
  
  return (
    <div style={{ 
      maxHeight: `${maxHeight}px`, 
      overflow: 'auto',
      padding: '16px'
    }}>
      <h2>Long Content</h2>
      <p>This content will scroll if it exceeds the max height...</p>
      {/* More content */}
    </div>
  );
}
```

**Best practices:**
- Always respect the `maxHeight` constraint
- Use `overflow: auto` to enable scrolling
- Consider the user's viewport size when designing layouts

**Available globals:**

| Key | Type | Description | Example |
|-----|------|-------------|---------|
| `theme` | `'light' \| 'dark'` | ChatGPT's current theme | `'dark'` |
| `displayMode` | `'inline' \| 'pip' \| 'fullscreen'` | Current display mode | `'inline'` |
| `locale` | `string` | User's preferred locale (IETF BCP 47) | `'en-US'`, `'fr-FR'` |
| `maxHeight` | `number` | Maximum height constraint in pixels | `600` |
| `safeArea` | `SafeArea` | Safe area insets for mobile layouts | `{ insets: { top: 20, ... }}` |
| `userAgent` | `UserAgent` | Device and capability information | `{ device: { type: 'mobile' }, ... }` |
| `toolInput` | `object` | Input parameters passed to your tool | `{ city: 'NYC' }` |
| `toolOutput` | `object` | Current tool output (same as `useWidgetProps()`) | `{ message: 'Hello' }` |
| `widgetState` | `object` | Current persistent state (same as `useWidgetState()`) | `{ count: 5 }` |

**Responsive layout example:**
```tsx
export default function ResponsiveWidget() {
  const displayMode = useOpenAiGlobal('displayMode');
  const userAgent = useOpenAiGlobal('userAgent');
  const safeArea = useOpenAiGlobal('safeArea');
  
  const isMobile = userAgent?.device.type === 'mobile';
  const isFullscreen = displayMode === 'fullscreen';
  
  return (
    <div style={{
      padding: isMobile ? '8px' : '16px',
      paddingTop: safeArea?.insets.top || 0,
      fontSize: isFullscreen ? '18px' : '14px'
    }}>
      {isMobile && <p>Mobile view</p>}
      {isFullscreen && <p>Fullscreen mode</p>}
    </div>
  );
}
```

---

## Advanced: Direct window.openai API

For advanced use cases, access the raw `window.openai` API directly:

### Call Tools from Your Component

Trigger server-side tool calls from your component (requires `widget_accessible=True` in Python):

```tsx
export default function RefreshableWidget() {
  const props = useWidgetProps();
  const [loading, setLoading] = React.useState(false);
  
  const handleRefresh = async () => {
    setLoading(true);
    try {
      await window.openai.callTool('refresh_data', {
        city: props.city
      });
      // Component will automatically re-render with new data
    } catch (error) {
      console.error('Failed to refresh:', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div>
      <button onClick={handleRefresh} disabled={loading}>
        {loading ? 'Refreshing...' : 'Refresh Data'}
      </button>
      <div>{props.data}</div>
    </div>
  );
}
```

**Important:** Set `widget_accessible = True` in your Python tool:
```python
class RefreshableWidget(BaseWidget):
    widget_accessible = True  # Enable component-initiated calls
```

---

### Send Follow-up Messages

Inject messages into the ChatGPT conversation:

```tsx
export default function InteractiveWidget() {
  const props = useWidgetProps();
  
  const handleAskMore = async (item) => {
    await window.openai.sendFollowUpMessage({
      prompt: `Tell me more about ${item.name}`
    });
  };
  
  return (
    <div>
      {props.items.map((item) => (
        <div key={item.id}>
          <h3>{item.name}</h3>
          <button onClick={() => handleAskMore(item)}>
            Ask ChatGPT about this
          </button>
        </div>
      ))}
    </div>
  );
}
```

---

### Request Display Mode Changes

Switch between inline, picture-in-picture, and fullscreen:

```tsx
export default function ExpandableWidget() {
  const displayMode = useOpenAiGlobal('displayMode');
  
  const goFullscreen = async () => {
    const result = await window.openai.requestDisplayMode({
      mode: 'fullscreen'
    });
    console.log('Granted mode:', result.mode);
    // Note: Host may reject or coerce the request
    // On mobile, PiP is always coerced to fullscreen
  };
  
  const goInline = async () => {
    await window.openai.requestDisplayMode({
      mode: 'inline'
    });
  };
  
  return (
    <div>
      <p>Current mode: {displayMode}</p>
      {displayMode !== 'fullscreen' && (
        <button onClick={goFullscreen}>
          Expand to Fullscreen
        </button>
      )}
      {displayMode === 'fullscreen' && (
        <button onClick={goInline}>
          Back to Inline
        </button>
      )}
    </div>
  );
}
```

---

### Open External Links

Open URLs in a new window or redirect:

```tsx
export default function LinkWidget() {
  const props = useWidgetProps();
  
  const openLink = (url: string) => {
    window.openai.openExternal({ href: url });
  };
  
  return (
    <div>
      {props.links.map((link) => (
        <button key={link.url} onClick={() => openLink(link.url)}>
          Visit {link.title}
        </button>
      ))}
    </div>
  );
}
```

---

## Complete Example: Advanced Widget

Here's a comprehensive example using all features:

```tsx
import React from 'react';
import { 
  useWidgetProps, 
  useWidgetState, 
  useOpenAiGlobal,
  useDisplayMode,
  useMaxHeight 
} from 'fastapps';

interface Place {
  id: string;
  name: string;
  rating: number;
  url: string;
}

interface PizzaListProps {
  places: Place[];
  city: string;
}

interface PizzaListState {
  favorites: string[];
  lastVisited: string | null;
}

export default function PizzaList() {
  // Get data from Python tool
  const props = useWidgetProps<PizzaListProps>();
  
  // Manage persistent state
  const [state, setState] = useWidgetState<PizzaListState>({
    favorites: [],
    lastVisited: null
  });
  
  // Access ChatGPT globals - using convenience hooks
  const theme = useOpenAiGlobal('theme');
  const displayMode = useDisplayMode();
  const maxHeight = useMaxHeight();
  const locale = useOpenAiGlobal('locale');
  
  // Toggle favorite
  const toggleFavorite = (placeId: string) => {
    const favorites = state.favorites.includes(placeId)
      ? state.favorites.filter(id => id !== placeId)
      : [...state.favorites, placeId];
    
    setState({ ...state, favorites });
  };
  
  // Refresh data from server
  const handleRefresh = async () => {
    await window.openai.callTool('refresh_pizza_list', {
      city: props.city
    });
  };
  
  // Ask follow-up about a place
  const askAboutPlace = async (place: Place) => {
    await window.openai.sendFollowUpMessage({
      prompt: `Tell me more about ${place.name}`
    });
  };
  
  // Open place website
  const visitPlace = (place: Place) => {
    setState({ ...state, lastVisited: place.id });
    window.openai.openExternal({ href: place.url });
  };
  
  // Request fullscreen for better view
  const expandView = async () => {
    await window.openai.requestDisplayMode({ mode: 'fullscreen' });
  };
  
  return (
    <div style={{
      background: theme === 'dark' ? '#1a1a1a' : '#ffffff',
      color: theme === 'dark' ? '#ffffff' : '#000000',
      padding: '16px',
      fontFamily: 'system-ui, sans-serif',
      maxHeight: `${maxHeight}px`,
      overflow: 'auto'
    }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <h2>üçï Pizza in {props.city}</h2>
        <div>
          <button onClick={handleRefresh} style={{ marginRight: '8px' }}>
            üîÑ Refresh
          </button>
          {displayMode !== 'fullscreen' && (
            <button onClick={expandView}>
              ‚õ∂ Expand
            </button>
          )}
        </div>
      </div>
      
      <p style={{ fontSize: '12px', opacity: 0.7 }}>
        Locale: {locale} | Mode: {displayMode} | Favorites: {state.favorites.length}
      </p>
      
      <div style={{ display: 'grid', gap: '12px', marginTop: '16px' }}>
        {props.places.map((place) => {
          const isFavorite = state.favorites.includes(place.id);
          const wasVisited = state.lastVisited === place.id;
          
          return (
            <div key={place.id} style={{
              padding: '12px',
              border: `1px solid ${theme === 'dark' ? '#333' : '#ddd'}`,
              borderRadius: '8px',
              background: wasVisited 
                ? (theme === 'dark' ? '#2a2a2a' : '#f0f0f0')
                : 'transparent'
            }}>
              <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                <h3 style={{ margin: 0 }}>{place.name}</h3>
                <button 
                  onClick={() => toggleFavorite(place.id)}
                  style={{ 
                    background: 'transparent', 
                    border: 'none',
                    fontSize: '20px',
                    cursor: 'pointer'
                  }}
                >
                  {isFavorite ? '‚ù§Ô∏è' : 'ü§ç'}
                </button>
              </div>
              
              <p style={{ margin: '8px 0' }}>
                ‚≠ê {place.rating.toFixed(1)}
                {wasVisited && ' ‚Ä¢ Recently visited'}
              </p>
              
              <div style={{ display: 'flex', gap: '8px', marginTop: '8px' }}>
                <button onClick={() => visitPlace(place)}>
                  Visit Website
                </button>
                <button onClick={() => askAboutPlace(place)}>
                  Ask ChatGPT
                </button>
              </div>
            </div>
          );
        })}
      </div>
      
      {state.favorites.length > 0 && (
        <div style={{ marginTop: '16px', padding: '12px', background: theme === 'dark' ? '#2a2a2a' : '#f0f0f0', borderRadius: '8px' }}>
          <p><strong>Your Favorites:</strong> {state.favorites.length} places</p>
        </div>
      )}
    </div>
  );
}
```

---

## TypeScript Support

All hooks include full TypeScript type definitions:

```tsx
import type { 
  OpenAiGlobals,
  Theme,
  DisplayMode,
  UserAgent,
  SafeArea 
} from 'fastapps';

// Strongly typed props
interface MyProps {
  message: string;
  count: number;
}

const props = useWidgetProps<MyProps>();
// props.message is string ‚úì
// props.count is number ‚úì

// Strongly typed state
interface MyState {
  items: string[];
}

const [state, setState] = useWidgetState<MyState>({ items: [] });
// state.items is string[] ‚úì

// All globals are typed
const theme: Theme | null = useOpenAiGlobal('theme');
const mode: DisplayMode | null = useOpenAiGlobal('displayMode');

// Convenience hooks are also typed
const displayMode: DisplayMode | null = useDisplayMode();
const maxHeight: number | null = useMaxHeight();
```

**Available hooks:**
- `useWidgetProps<T>(defaultState?)` - Access tool output with optional fallback
- `useWidgetState<T>(defaultState)` - Persistent state management
- `useOpenAiGlobal(key)` - Access any global property
- `useDisplayMode()` - Get display mode (convenience)
- `useMaxHeight()` - Get max height (convenience)

**Creating custom convenience hooks:**

You can easily create your own convenience hooks for frequently accessed globals:

```tsx
import { useOpenAiGlobal } from 'fastapps';

// Custom hook for theme
export function useTheme() {
  return useOpenAiGlobal('theme');
}

// Custom hook for tool input
export function useToolInput<T = any>() {
  return useOpenAiGlobal('toolInput') as T | null;
}

// Custom hook for locale
export function useLocale() {
  return useOpenAiGlobal('locale');
}
```

---

## Best Practices

**Component Structure:**
- Keep components pure and deterministic
- Use inline styles for fast iteration
- Extract shared utilities to `widgets/shared/`
- Handle loading and empty states explicitly

**State Management:**
- Use `useWidgetState()` for data that needs to persist
- Use local `useState()` for ephemeral UI state
- Keep state payloads small (< 4KB recommended)
- Don't store large datasets in widget state

**Performance:**
- Memoize expensive computations with `useMemo()`
- Avoid unnecessary re-renders with `React.memo()`
- Use `useCallback()` for event handlers passed to children
- Keep component bundles small (< 100KB recommended)

**Layout & Responsiveness:**
- Always respect `maxHeight` from `useOpenAiGlobal('maxHeight')`
- Use `safeArea` insets for mobile layouts
- Check `userAgent.device.type` for device-specific layouts
- Support both light and dark themes

**User Experience:**
- Provide loading states when calling tools
- Show error messages when operations fail
- Use `sendFollowUpMessage()` to guide conversations
- Request fullscreen only when necessary

**Security:**
- Validate all user inputs before passing to `callTool()`
- Never expose sensitive data in widget state
- Use `openExternal()` for untrusted URLs
- Follow CSP rules defined in Python tool
