---
title: "API Integration Best Practices"
description: "Learn how to integrate APIs effectively, handle errors gracefully, and optimize data fetching in your applications."
date: "2024-10-15"
author:
  name: "David Im"
  image: ""
category: "technical"
tags: ["api", "rest", "graphql", "best-practices", "performance"]
image: "/screens/screen-4.png"
published: true
---

# API Integration Best Practices

Building robust API integrations is crucial for modern applications. In this guide, we'll cover best practices for fetching data, handling errors, and optimizing performance.

## Setting Up API Routes

### Creating an API Route

Define API routes in your `app/api` directory:

```typescript
// app/api/users/route.ts
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const id = searchParams.get('id')
  
  try {
    const user = await fetchUser(id)
    return Response.json(user)
  } catch (error) {
    return Response.json(
      { error: 'Failed to fetch user' },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  const body = await request.json()
  
  // Validate input
  if (!body.name || !body.email) {
    return Response.json(
      { error: 'Name and email are required' },
      { status: 400 }
    )
  }
  
  const user = await createUser(body)
  return Response.json(user, { status: 201 })
}
```

## Data Fetching Patterns

### Server Components

Fetch data directly in Server Components:

```tsx
async function UserProfile({ userId }: { userId: string }) {
  const user = await fetch(`/api/users/${userId}`, {
    cache: 'force-cache', // or 'no-store' for dynamic data
  }).then(res => res.json())
  
  return <div>{user.name}</div>
}
```

### Client Components with SWR

For client-side data fetching, use SWR:

```tsx
'use client'

import useSWR from 'swr'

const fetcher = (url: string) => fetch(url).then(r => r.json())

function UserList() {
  const { data, error, isLoading, mutate } = useSWR(
    '/api/users',
    fetcher,
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: true,
    }
  )
  
  if (isLoading) return <Loading />
  if (error) return <Error error={error} />
  
  return (
    <div>
      {data.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  )
}
```

### React Query

Alternatively, use React Query for advanced caching:

```tsx
'use client'

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

function Users() {
  const queryClient = useQueryClient()
  
  const { data, isLoading } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(r => r.json()),
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
  
  const createUser = useMutation({
    mutationFn: (newUser) => 
      fetch('/api/users', {
        method: 'POST',
        body: JSON.stringify(newUser),
      }).then(r => r.json()),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] })
    },
  })
  
  return (
    <div>
      {/* Your UI */}
    </div>
  )
}
```

## Error Handling

### Centralized Error Handler

Create a reusable error handler:

```typescript
// lib/api-error.ts
export class APIError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code?: string
  ) {
    super(message)
    this.name = 'APIError'
  }
}

export function handleAPIError(error: unknown): Response {
  if (error instanceof APIError) {
    return Response.json(
      { error: error.message, code: error.code },
      { status: error.statusCode }
    )
  }
  
  console.error('Unexpected error:', error)
  return Response.json(
    { error: 'Internal server error' },
    { status: 500 }
  )
}
```

### Client-Side Error Handling

Handle errors gracefully in your components:

```tsx
function UserProfile() {
  const { data, error } = useSWR('/api/user')
  
  if (error) {
    if (error.status === 404) {
      return <NotFound />
    }
    
    if (error.status === 401) {
      return <Unauthorized />
    }
    
    return (
      <ErrorBoundary
        error={error}
        onRetry={() => mutate('/api/user')}
      />
    )
  }
  
  return <Profile user={data} />
}
```

## Caching Strategies

### Cache-Control Headers

Set appropriate cache headers:

```typescript
export async function GET() {
  const data = await fetchData()
  
  return Response.json(data, {
    headers: {
      'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=30'
    }
  })
}
```

### ISR (Incremental Static Regeneration)

Revalidate data at specified intervals:

```tsx
export const revalidate = 3600 // Revalidate every hour

async function BlogPost({ slug }: { slug: string }) {
  const post = await fetch(`/api/posts/${slug}`)
  return <Article post={post} />
}
```

## Rate Limiting

### Implementing Rate Limiting

Protect your APIs with rate limiting:

```typescript
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '10 s'),
})

export async function POST(request: Request) {
  const ip = request.headers.get('x-forwarded-for') ?? 'anonymous'
  const { success, limit, remaining } = await ratelimit.limit(ip)
  
  if (!success) {
    return Response.json(
      { error: 'Rate limit exceeded' },
      { 
        status: 429,
        headers: {
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
        }
      }
    )
  }
  
  // Process request
}
```

## Authentication

### JWT Authentication

Implement JWT-based authentication:

```typescript
import { SignJWT, jwtVerify } from 'jose'

export async function createToken(userId: string) {
  const secret = new TextEncoder().encode(process.env.JWT_SECRET)
  
  return await new SignJWT({ userId })
    .setProtectedHeader({ alg: 'HS256' })
    .setExpirationTime('24h')
    .sign(secret)
}

export async function verifyToken(token: string) {
  const secret = new TextEncoder().encode(process.env.JWT_SECRET)
  
  try {
    const { payload } = await jwtVerify(token, secret)
    return payload
  } catch (error) {
    throw new APIError('Invalid token', 401)
  }
}

// Middleware
export async function authenticateRequest(request: Request) {
  const authHeader = request.headers.get('authorization')
  
  if (!authHeader?.startsWith('Bearer ')) {
    throw new APIError('Unauthorized', 401)
  }
  
  const token = authHeader.substring(7)
  return await verifyToken(token)
}
```

## Testing APIs

### Unit Testing

Test your API routes:

```typescript
import { GET, POST } from './route'

describe('Users API', () => {
  it('should fetch users', async () => {
    const request = new Request('http://localhost/api/users')
    const response = await GET(request)
    const data = await response.json()
    
    expect(response.status).toBe(200)
    expect(Array.isArray(data)).toBe(true)
  })
  
  it('should create user', async () => {
    const request = new Request('http://localhost/api/users', {
      method: 'POST',
      body: JSON.stringify({
        name: 'John Doe',
        email: 'john@example.com',
      }),
    })
    
    const response = await POST(request)
    expect(response.status).toBe(201)
  })
})
```

## Performance Optimization

### 1. Use Parallel Requests

Fetch data in parallel when possible:

```typescript
async function Dashboard() {
  const [users, posts, stats] = await Promise.all([
    fetch('/api/users'),
    fetch('/api/posts'),
    fetch('/api/stats'),
  ])
  
  return <DashboardView data={{ users, posts, stats }} />
}
```

### 2. Implement Pagination

Always paginate large datasets:

```typescript
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const page = parseInt(searchParams.get('page') ?? '1')
  const limit = parseInt(searchParams.get('limit') ?? '10')
  
  const offset = (page - 1) * limit
  
  const [data, total] = await Promise.all([
    db.users.findMany({ skip: offset, take: limit }),
    db.users.count(),
  ])
  
  return Response.json({
    data,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit),
    },
  })
}
```

### 3. Use Compression

Enable compression for API responses:

```typescript
export async function GET() {
  const data = await fetchLargeDataset()
  
  return Response.json(data, {
    headers: {
      'Content-Encoding': 'gzip',
    },
  })
}
```

## Conclusion

Following these best practices will help you build robust, scalable, and maintainable API integrations. Remember to:

1. Handle errors gracefully
2. Implement proper caching
3. Secure your endpoints
4. Test thoroughly
5. Monitor performance

Happy coding! ðŸš€

