[
  {
    "slug": "/api-integration",
    "title": "API Integration",
    "description": "Connect FastApps widgets to external APIs from Python tools and display results in React.",
    "content": "Learn how to integrate external APIs into your FastApps widgets.\n\n## Overview\n\nAPI integration happens in two places:\n\n1. **Python Tool** - Makes the API call, processes data\n2. **React Component** - Displays the data\n\n## Basic API Call\n\n### Python Tool\n\n```python\nimport httpx\nfrom fastapps import BaseWidget, Field, ConfigDict\nfrom pydantic import BaseModel\nfrom typing import Dict, Any\n\nclass WeatherInput(BaseModel):\n    model_config = ConfigDict(populate_by_name=True)\n    city: str = Field(..., description=\"City to fetch weather for\")\n\nclass WeatherWidget(BaseWidget):\n    identifier = \"weather\"\n    input_model = WeatherInput\n\n    async def execute(self, inputs: WeatherInput) -> Dict[str, Any]:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                \"https://api.weatherapi.com/v1/current.json\",\n                params={\"q\": inputs.city},\n            )\n        data = response.json()\n        return {\"city\": inputs.city, \"forecast\": data[\"current\"]}\n```\n\n### React Component\n\n```jsx\nimport React from \"react\";\nimport { useWidgetProps } from \"chatjs-hooks\";\n\nexport default function WeatherWidget() {\n  const { city, forecast } = useWidgetProps();\n\n  if (!forecast) {\n    return <p>Unable to load weather data.</p>;\n  }\n\n  return (\n    <div>\n      <h2>{city}</h2>\n      <p>{forecast.condition.text}</p>\n      <p>{forecast.temp_f}Â°F</p>\n    </div>\n  );\n}\n```\n\n## Handling Errors\n\n```python\ntry:\n    response.raise_for_status()\nexcept httpx.HTTPStatusError:\n    return {\"error\": \"Weather service unavailable\"}\n```\n\nOn the frontend:\n\n```jsx\nif (props.error) {\n  return <p>Sorry, try again later.</p>;\n}\n```\n\n## Authentication\n\n* Use environment variables for API keys\n* Load them in Python with `os.getenv`\n* Never expose secrets in the widget props\n\n## Rate Limits\n\n* Cache responses when possible\n* Debounce user-triggered fetches\n* Provide helpful fallback messages\n\n## Async vs Sync\n\n* Prefer async tools when calling APIs\n* For blocking libraries, run them in executors to keep FastApps responsive\n",
    "_searchMeta": {
      "cleanContent": "learn how to integrate external apis into your fastapps widgets overview api integration happens in two places: python tool - makes the api call processes data react component - displays the data basic api call python tool react component handling errors on the frontend: authentication use environment variables for api keys load them in python with os getenv never expose secrets in the widget props rate limits cache responses when possible debounce user-triggered fetches provide helpful fallback messages async vs sync prefer async tools when calling apis for blocking libraries run them in executors to keep fastapps responsive",
      "headings": [
        "Overview",
        "Basic API Call",
        "Handling Errors",
        "Authentication",
        "Rate Limits",
        "Async vs Sync"
      ],
      "keywords": [
        "Overview",
        "Basic API Call",
        "Handling Errors",
        "Authentication",
        "Rate Limits",
        "Async vs Sync",
        "Python Tool",
        "React Component",
        "python\nimport httpx\nfrom fastapps import BaseWidget, Field, ConfigDict\nfrom pydantic import BaseModel\nfrom typing import Dict, Any\n\nclass WeatherInput(BaseModel):\n    model_config = ConfigDict(populate_by_name=True)\n    city: str = Field(..., description=\"City to fetch weather for\")\n\nclass WeatherWidget(BaseWidget):\n    identifier = \"weather\"\n    input_model = WeatherInput\n\n    async def execute(self, inputs: WeatherInput) -> Dict[str, Any]:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                \"https://api.weatherapi.com/v1/current.json\",\n                params={\"q\": inputs.city},\n            )\n        data = response.json()\n        return {\"city\": inputs.city, \"forecast\": data[\"current\"]}",
        "### React Component",
        "jsx\nimport React from \"react\";\nimport { useWidgetProps } from \"chatjs-hooks\";\n\nexport default function WeatherWidget() {\n  const { city, forecast } = useWidgetProps();\n\n  if (!forecast) {\n    return <p>Unable to load weather data.</p>;\n  }\n\n  return (\n    <div>\n      <h2>{city}</h2>\n      <p>{forecast.condition.text}</p>\n      <p>{forecast.temp_f}Â°F</p>\n    </div>\n  );\n}",
        "## Handling Errors",
        "python\ntry:\n    response.raise_for_status()\nexcept httpx.HTTPStatusError:\n    return {\"error\": \"Weather service unavailable\"}",
        "On the frontend:",
        "jsx\nif (props.error) {\n  return <p>Sorry, try again later.</p>;\n}",
        "## Authentication\n\n* Use environment variables for API keys\n* Load them in Python with"
      ]
    }
  },
  {
    "slug": "/api-reference",
    "title": "FastApps API Reference",
    "description": "Reference documentation for the FastApps runtime, BaseWidget class, and helper utilities.",
    "content": "Complete API documentation for the FastApps framework.\n\n## Core Classes\n\n### `BaseWidget`\n\nThe base class for all FastApps widgets.\n\n```python\nfrom fastapps import BaseWidget\n```\n\n#### Class Attributes\n\n**`identifier: str`** (required)\n\n* Unique widget identifier\n* Must match the widget folder name in `widgets/`\n* Example: `\"greeting\"` for `widgets/greeting/`\n\n**`input_model: Type[BaseModel]`**\n\n* Pydantic model describing tool inputs\n* Enables validation and type hints\n\n**`name: str | None`**\n\n* Human-friendly label shown in dashboards\n* Defaults to `identifier` when omitted\n\n#### Methods\n\n**`execute(self, inputs, ctx)`**\n\n* Main entry point for your tool\n* Return serializable data consumed by the widget\n\n**`async execute`**\n\n* Mark as `async` when you call network services\n* FastApps awaits the coroutine automatically\n\n## `FastApps` Client\n\n```python\nfrom fastapps import FastApps\n\napp = FastApps()\napp.register(GreetingWidget)\n```\n\n### Methods\n\n**`register(widget_cls)`**\n\n* Register a widget class manually\n* Useful when auto-discovery is disabled\n\n**`discover(path)`**\n\n* Recursively import modules and register widgets\n* Typical usage: `discover(\"server.tools\")`\n\n**`call(identifier, **kwargs)`**\n\n* Invoke a widget tool programmatically\n* Returns the JSON payload you send to the widget\n\n## Context Helpers\n\n### `WidgetContext`\n\nProvides access to:\n\n* `state`: persistence helpers (`get`, `set`, `delete`)\n* `logger`: structured logging for observability\n* `settings`: runtime configuration (API keys, env flags)\n\n### State Helpers\n\n```python\nawait ctx.state.get(\"count\", default=0)\nawait ctx.state.set(\"count\", 1)\nawait ctx.state.clear()\n```\n\n## Error Handling\n\n* Raise domain-specific exceptions; FastApps serializes the message\n* Use `ctx.logger.exception` to capture stack traces\n* Return fallback data so widgets can render graceful errors\n\n## CLI Commands\n\n```bash\nfastapps create <name>   # Scaffold a new widget\nfastapps dev             # Run dev server with hot reload\nfastapps build           # Bundle widget assets\n```\n\n* `fastapps deploy` integrates with Flick to publish widgets\n* Pass `--python` or `--node` to customize runtimes\n\n## Version Compatibility\n\n* FastApps Python SDK targets Python 3.9+\n* React widgets are built with React 18\n* ChatJS hooks provide the widget bridge (installed automatically)\n\nLeverage these APIs to integrate FastApps deeply into your workflows.\n",
    "_searchMeta": {
      "cleanContent": "complete api documentation for the fastapps framework core classes basewidget the base class for all fastapps widgets class attributes identifier: str required unique widget identifier must match the widget folder name in widgets example: greeting for widgets greeting input_model: type basemodel pydantic model describing tool inputs enables validation and type hints name: str none human-friendly label shown in dashboards defaults to identifier when omitted methods execute self inputs ctx main entry point for your tool return serializable data consumed by the widget async execute mark as async when you call network services fastapps awaits the coroutine automatically fastapps client methods register widget_cls register a widget class manually useful when auto-discovery is disabled discover path recursively import modules and register widgets typical usage: discover server tools call identifier kwargs invoke a widget tool programmatically returns the json payload you send to the widget context helpers widgetcontext provides access to: state: persistence helpers get set delete logger: structured logging for observability settings: runtime configuration api keys env flags state helpers error handling raise domain-specific exceptions fastapps serializes the message use ctx logger exception to capture stack traces return fallback data so widgets can render graceful errors cli commands fastapps deploy integrates with flick to publish widgets pass --python or --node to customize runtimes version compatibility fastapps python sdk targets python 3 9 react widgets are built with react 18 chatjs hooks provide the widget bridge installed automatically leverage these apis to integrate fastapps deeply into your workflows",
      "headings": [
        "Core Classes",
        "`FastApps` Client",
        "Context Helpers",
        "Error Handling",
        "CLI Commands",
        "Version Compatibility"
      ],
      "keywords": [
        "Core Classes",
        "`FastApps` Client",
        "Context Helpers",
        "Error Handling",
        "CLI Commands",
        "Version Compatibility",
        "`identifier: str`",
        "`input_model: Type[BaseModel]`",
        "`name: str | None`",
        "`execute(self, inputs, ctx)`",
        "`async execute`",
        "`register(widget_cls)`",
        "`discover(path)`",
        "`call(identifier,",
        "BaseWidget",
        "python\nfrom fastapps import BaseWidget",
        "#### Class Attributes\n\n**",
        "** (required)\n\n* Unique widget identifier\n* Must match the widget folder name in",
        "* Example:",
        "for",
        "**",
        "**\n\n* Pydantic model describing tool inputs\n* Enables validation and type hints\n\n**",
        "**\n\n* Human-friendly label shown in dashboards\n* Defaults to",
        "when omitted\n\n#### Methods\n\n**",
        "**\n\n* Main entry point for your tool\n* Return serializable data consumed by the widget\n\n**",
        "**\n\n* Mark as",
        "when you call network services\n* FastApps awaits the coroutine automatically\n\n##",
        "Client",
        "python\nfrom fastapps import FastApps\n\napp = FastApps()\napp.register(GreetingWidget)",
        "### Methods\n\n**",
        "**\n\n* Register a widget class manually\n* Useful when auto-discovery is disabled\n\n**",
        "**\n\n* Recursively import modules and register widgets\n* Typical usage:",
        "**\n\n* Invoke a widget tool programmatically\n* Returns the JSON payload you send to the widget\n\n## Context Helpers\n\n###",
        "Provides access to:\n\n*",
        ": persistence helpers (",
        ",",
        ")\n*",
        ": structured logging for observability\n*",
        ": runtime configuration (API keys, env flags)\n\n### State Helpers",
        "python\nawait ctx.state.get(\"count\", default=0)\nawait ctx.state.set(\"count\", 1)\nawait ctx.state.clear()",
        "## Error Handling\n\n* Raise domain-specific exceptions; FastApps serializes the message\n* Use",
        "to capture stack traces\n* Return fallback data so widgets can render graceful errors\n\n## CLI Commands",
        "bash\nfastapps create <name>   # Scaffold a new widget\nfastapps dev             # Run dev server with hot reload\nfastapps build           # Bundle widget assets",
        "*",
        "integrates with Flick to publish widgets\n* Pass",
        "or"
      ]
    }
  },
  {
    "slug": "/introduction",
    "title": "Introduction to FastApps",
    "description": "Understand what FastApps is, why it exists, and how it upgrades ChatGPT development.",
    "content": "Welcome to FastApps - a zero-boilerplate framework for building interactive ChatGPT widgets!\n\n## What is FastApps?\n\nFastApps is a Python framework that lets you build interactive, visual widgets for ChatGPT with minimal code. Instead of text-only responses, you can create rich, interactive UIs that run directly in ChatGPT.\n\n## Why FastApps?\n\n### Traditional ChatGPT Development\n\n```python\n# Just text responses\ndef my_tool():\n    return \"Here's the weather: 72Â°F, Sunny\"\n```\n\n### With FastApps\n\n```python\n# Rich, interactive widgets\ndef my_tool():\n    return Widget(\n        title=\"Weather Widget\",\n        data={\n            \"temperature\": 72,\n            \"conditions\": \"Sunny\",\n        },\n    )\n```\n\n## Key Benefits\n\n* Create production-quality UI widgets with minimal setup\n* Keep Python business logic and React presentation in sync\n* Support interactive states, forms, and live updates\n* Build demos and tools that feel native to ChatGPT\n\n## Why Widgets Matter\n\nTraditional ChatGPT tools answer with text. FastApps widgets add visual structure, controls, and interactivity that help users take action faster. Whether you're building dashboards, data explorers, or guided workflows, widgets give you the UI you need without leaving ChatGPT.\n\n## How FastApps Works\n\n1. **Python Tool** â€” Handles inputs, business logic, and data fetching.\n2. **React Widget** â€” Renders the UI, receives data from Python, and handles user interaction.\n3. **FastApps Runtime** â€” Connects the two, synchronizes state, and delivers the widget through ChatGPT.\n\n## What's Next?\n\n* Follow the Quick Start to get a widget running in minutes.\n* Explore the Project Setup guide to understand the file structure.\n* Dive into Widgets, Tools, State, Styling, and API guides for deeper knowledge.\n\nFastApps brings modern app patterns to AI-driven conversations. You're about to build experiences that feel magical inside ChatGPT.\n",
    "_searchMeta": {
      "cleanContent": "welcome to fastapps - a zero-boilerplate framework for building interactive chatgpt widgets what is fastapps fastapps is a python framework that lets you build interactive visual widgets for chatgpt with minimal code instead of text-only responses you can create rich interactive uis that run directly in chatgpt why fastapps traditional chatgpt development with fastapps key benefits create production-quality ui widgets with minimal setup keep python business logic and react presentation in sync support interactive states forms and live updates build demos and tools that feel native to chatgpt why widgets matter traditional chatgpt tools answer with text fastapps widgets add visual structure controls and interactivity that help users take action faster whether you re building dashboards data explorers or guided workflows widgets give you the ui you need without leaving chatgpt how fastapps works python tool handles inputs business logic and data fetching react widget renders the ui receives data from python and handles user interaction fastapps runtime connects the two synchronizes state and delivers the widget through chatgpt what s next follow the quick start to get a widget running in minutes explore the project setup guide to understand the file structure dive into widgets tools state styling and api guides for deeper knowledge fastapps brings modern app patterns to ai-driven conversations you re about to build experiences that feel magical inside chatgpt",
      "headings": [
        "What is FastApps?",
        "Why FastApps?",
        "Key Benefits",
        "Why Widgets Matter",
        "How FastApps Works",
        "What's Next?"
      ],
      "keywords": [
        "What is FastApps?",
        "Why FastApps?",
        "Key Benefits",
        "Why Widgets Matter",
        "How FastApps Works",
        "What's Next?",
        "Python Tool",
        "React Widget",
        "FastApps Runtime",
        "python\n# Just text responses\ndef my_tool():\n    return \"Here's the weather: 72Â°F, Sunny\"",
        "### With FastApps",
        "python\n# Rich, interactive widgets\ndef my_tool():\n    return Widget(\n        title=\"Weather Widget\",\n        data={\n            \"temperature\": 72,\n            \"conditions\": \"Sunny\",\n        },\n    )"
      ]
    }
  },
  {
    "slug": "/project-setup",
    "title": "Complete Project Setup",
    "description": "Assemble the recommended FastApps project structure and required configuration files.",
    "content": "This guide shows you exactly what files you need to create for a new FastApps project.\n\n## ğŸ“ Initial Project Structure\n\n```bash\nmy-chatgpt-widgets/\nâ”œâ”€â”€ server/\nâ”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”œâ”€â”€ main.py\nâ”‚   â”œâ”€â”€ tools/\nâ”‚   â”‚   â””â”€â”€ __init__.py\nâ”‚   â””â”€â”€ api/                # (optional)\nâ”‚       â””â”€â”€ __init__.py\nâ”‚\nâ”œâ”€â”€ widgets/                # (empty initially)\nâ”‚\nâ”œâ”€â”€ requirements.txt\nâ””â”€â”€ package.json\n```\n\n## ğŸ”§ Required Files\n\n### `server/main.py`\n\n```python\nfrom fastapps import FastApps, discover_tools\n\napp = FastApps()\n\ndiscover_tools(app, \"server.tools\")\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\n### `server/tools/__init__.py`\n\n```python\n# Ensures tools package imports correctly\n```\n\n### `widgets/__init__.py`\n\nNot required â€” widgets are pure frontend code.\n\n## ğŸª„ Auto-Discovery\n\n* FastApps scans `server/tools` for subclasses of `BaseWidget`\n* The widget identifier must match the folder name in `widgets/`\n* React components live in `widgets/<identifier>/index.jsx`\n\n## ğŸ—‚ Recommended Extras\n\n* `server/api/` for shared API clients\n* `flick.config.json` if you integrate with the Flick CLI\n* `.env` for secrets used by your tools\n\n## âœ… Checklist\n\n* \\[ ] Create the folder structure\n* \\[ ] Implement at least one tool and widget\n* \\[ ] Run `fastapps dev`\n* \\[ ] Confirm the widget renders in ChatGPT\n",
    "_searchMeta": {
      "cleanContent": "this guide shows you exactly what files you need to create for a new fastapps project initial project structure required files server main py server tools _init_ py widgets _init_ py not required widgets are pure frontend code auto-discovery fastapps scans server tools for subclasses of basewidget the widget identifier must match the folder name in widgets react components live in widgets identifier index jsx recommended extras server api for shared api clients flick config json if you integrate with the flick cli env for secrets used by your tools checklist create the folder structure implement at least one tool and widget run fastapps dev confirm the widget renders in chatgpt",
      "headings": [
        "ğŸ“ Initial Project Structure",
        "ğŸ”§ Required Files",
        "ğŸª„ Auto-Discovery",
        "ğŸ—‚ Recommended Extras",
        "âœ… Checklist"
      ],
      "keywords": [
        "ğŸ“ Initial Project Structure",
        "ğŸ”§ Required Files",
        "ğŸª„ Auto-Discovery",
        "ğŸ—‚ Recommended Extras",
        "âœ… Checklist",
        "bash\nmy-chatgpt-widgets/\nâ”œâ”€â”€ server/\nâ”‚   â”œâ”€â”€ __init__.py\nâ”‚   â”œâ”€â”€ main.py\nâ”‚   â”œâ”€â”€ tools/\nâ”‚   â”‚   â””â”€â”€ __init__.py\nâ”‚   â””â”€â”€ api/                # (optional)\nâ”‚       â””â”€â”€ __init__.py\nâ”‚\nâ”œâ”€â”€ widgets/                # (empty initially)\nâ”‚\nâ”œâ”€â”€ requirements.txt\nâ””â”€â”€ package.json",
        "## ğŸ”§ Required Files\n\n###",
        "",
        "python\nfrom fastapps import FastApps, discover_tools\n\napp = FastApps()\n\ndiscover_tools(app, \"server.tools\")\n\nif __name__ == \"__main__\":\n    app.run()",
        "###",
        "python\n# Ensures tools package imports correctly",
        "Not required â€” widgets are pure frontend code.\n\n## ğŸª„ Auto-Discovery\n\n* FastApps scans",
        "for subclasses of",
        "* The widget identifier must match the folder name in",
        "* React components live in",
        "## ğŸ—‚ Recommended Extras\n\n*",
        "for shared API clients\n*",
        "if you integrate with the Flick CLI\n*",
        "for secrets used by your tools\n\n## âœ… Checklist\n\n* \\[ ] Create the folder structure\n* \\[ ] Implement at least one tool and widget\n* \\[ ] Run"
      ]
    }
  },
  {
    "slug": "/quickstart",
    "title": "FastApps Quick Start",
    "description": "Spin up your first FastApps project and run a widget in under five minutes.",
    "content": "Get your first ChatGPT widget running in 5 minutes!\n\n## ğŸ“ What Gets Created\n\nWhen you run `fastapps create greeting`, this structure is generated:\n\n```\nmy-widgets/\nâ”œâ”€â”€ server/\nâ”‚   â”œâ”€â”€ __init__.py              # Empty file\nâ”‚   â”œâ”€â”€ main.py                  # Auto-discovery server (pre-configured)\nâ”‚   â””â”€â”€ tools/\nâ”‚       â”œâ”€â”€ __init__.py          # Empty file\nâ”‚       â””â”€â”€ greeting_tool.py     # â† YOUR CODE: Widget backend\nâ”‚\nâ”œâ”€â”€ widgets/\nâ”‚   â””â”€â”€ greeting/\nâ”‚       â””â”€â”€ index.jsx            # â† YOUR CODE: Widget frontend\nâ”‚\nâ”œâ”€â”€ requirements.txt\nâ””â”€â”€ package.json\n```\n\n## ğŸš€ Create Your First Widget\n\n```bash\npip install fastapps\nfastapps create greeting\n```\n\n* Installs dependencies\n* Creates a Python tool in `server/tools/`\n* Generates a React widget in `widgets/`\n* Wires everything into the FastApps runtime\n\n## â–¶ï¸ Run the Development Server\n\n```bash\nfastapps dev\n```\n\n* Starts the FastApps dev server\n* Hot reloads your Python and React code\n* Opens the preview in ChatGPT-compatible mode\n\n## ğŸ§ª Test the Widget\n\nCall your widget from Python:\n\n```python\nfrom fastapps import FastApps\n\nclient = FastApps()\nresponse = client.call(\"greeting\", name=\"Ada\")\nprint(response)\n```\n\nThe widget renders inside ChatGPT with the provided data.\n\n## âœ… Ready for Next Steps\n\n* Follow the Tutorial for a guided build\n* Explore Widgets and Tools to customize logic and UI\n* Connect APIs or state management when you need more power\n",
    "_searchMeta": {
      "cleanContent": "get your first chatgpt widget running in 5 minutes what gets created when you run fastapps create greeting this structure is generated: create your first widget installs dependencies creates a python tool in server tools generates a react widget in widgets wires everything into the fastapps runtime run the development server starts the fastapps dev server hot reloads your python and react code opens the preview in chatgpt-compatible mode test the widget call your widget from python: the widget renders inside chatgpt with the provided data ready for next steps follow the tutorial for a guided build explore widgets and tools to customize logic and ui connect apis or state management when you need more power",
      "headings": [
        "ğŸ“ What Gets Created",
        "ğŸš€ Create Your First Widget",
        "â–¶ï¸ Run the Development Server",
        "ğŸ§ª Test the Widget",
        "âœ… Ready for Next Steps"
      ],
      "keywords": [
        "ğŸ“ What Gets Created",
        "ğŸš€ Create Your First Widget",
        "â–¶ï¸ Run the Development Server",
        "ğŸ§ª Test the Widget",
        "âœ… Ready for Next Steps",
        "fastapps create greeting",
        "my-widgets/\nâ”œâ”€â”€ server/\nâ”‚   â”œâ”€â”€ __init__.py              # Empty file\nâ”‚   â”œâ”€â”€ main.py                  # Auto-discovery server (pre-configured)\nâ”‚   â””â”€â”€ tools/\nâ”‚       â”œâ”€â”€ __init__.py          # Empty file\nâ”‚       â””â”€â”€ greeting_tool.py     # â† YOUR CODE: Widget backend\nâ”‚\nâ”œâ”€â”€ widgets/\nâ”‚   â””â”€â”€ greeting/\nâ”‚       â””â”€â”€ index.jsx            # â† YOUR CODE: Widget frontend\nâ”‚\nâ”œâ”€â”€ requirements.txt\nâ””â”€â”€ package.json",
        "## ğŸš€ Create Your First Widget",
        "bash\npip install fastapps\nfastapps create greeting",
        "* Installs dependencies\n* Creates a Python tool in",
        "* Generates a React widget in",
        "* Wires everything into the FastApps runtime\n\n## â–¶ï¸ Run the Development Server",
        "bash\nfastapps dev",
        "* Starts the FastApps dev server\n* Hot reloads your Python and React code\n* Opens the preview in ChatGPT-compatible mode\n\n## ğŸ§ª Test the Widget\n\nCall your widget from Python:",
        "python\nfrom fastapps import FastApps\n\nclient = FastApps()\nresponse = client.call(\"greeting\", name=\"Ada\")\nprint(response)"
      ]
    }
  },
  {
    "slug": "/state",
    "title": "Managing Widget State",
    "description": "Persist and synchronize widget state between ChatGPT sessions and user interactions.",
    "content": "Learn how to create stateful, interactive widgets that persist data across interactions.\n\n## What is Widget State?\n\nWidget state is data that:\n\n* Persists across widget interactions\n* Survives page refreshes\n* Is stored in ChatGPT's conversation context\n* Can be updated from your React component\n\n## Basic State Management\n\n### `useWidgetState` Hook\n\n```jsx\nimport { useWidgetState } from \"chatjs-hooks\";\n\nexport default function Counter() {\n  const [count, setCount] = useWidgetState(\"count\", 0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n```\n\n### Persist Multiple Values\n\n```jsx\nconst [filters, setFilters] = useWidgetState(\"filters\", {\n  search: \"\",\n  sort: \"best\",\n});\n```\n\n## Sync State to Python\n\n```python\nclass CounterWidget(BaseWidget):\n    identifier = \"counter\"\n\n    async def execute(self, inputs: CounterInput, ctx: WidgetContext):\n        count = await ctx.state.get(\"count\", default=0)\n        return {\"count\": count}\n```\n\nUse `ctx.state.set(\"count\", value)` in the widget via action handlers to push updates back to Python if needed.\n\n## Resetting State\n\n* Call `resetWidgetState()` from the frontend to clear all values\n* Or use `useWidgetState(key, default, { resetOnUnmount: true })`\n\n## Tips\n\n* Keep state keys stable across renders\n* Store serializable values (objects, arrays, numbers, strings)\n* Use server-provided defaults for first render\n* Combine with API calls to cache results per conversation\n",
    "_searchMeta": {
      "cleanContent": "learn how to create stateful interactive widgets that persist data across interactions what is widget state widget state is data that: persists across widget interactions survives page refreshes is stored in chatgpt s conversation context can be updated from your react component basic state management usewidgetstate hook persist multiple values sync state to python use ctx state set count value in the widget via action handlers to push updates back to python if needed resetting state call resetwidgetstate from the frontend to clear all values or use usewidgetstate key default resetonunmount: true tips keep state keys stable across renders store serializable values objects arrays numbers strings use server-provided defaults for first render combine with api calls to cache results per conversation",
      "headings": [
        "What is Widget State?",
        "Basic State Management",
        "Sync State to Python",
        "Resetting State",
        "Tips"
      ],
      "keywords": [
        "What is Widget State?",
        "Basic State Management",
        "Sync State to Python",
        "Resetting State",
        "Tips",
        "useWidgetState",
        "jsx\nimport { useWidgetState } from \"chatjs-hooks\";\n\nexport default function Counter() {\n  const [count, setCount] = useWidgetState(\"count\", 0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
        "### Persist Multiple Values",
        "jsx\nconst [filters, setFilters] = useWidgetState(\"filters\", {\n  search: \"\",\n  sort: \"best\",\n});",
        "## Sync State to Python",
        "python\nclass CounterWidget(BaseWidget):\n    identifier = \"counter\"\n\n    async def execute(self, inputs: CounterInput, ctx: WidgetContext):\n        count = await ctx.state.get(\"count\", default=0)\n        return {\"count\": count}",
        "Use",
        "in the widget via action handlers to push updates back to Python if needed.\n\n## Resetting State\n\n* Call",
        "from the frontend to clear all values\n* Or use"
      ]
    }
  },
  {
    "slug": "/styling",
    "title": "Styling Guide",
    "description": "Style FastApps widgets with inline techniques and lightweight design patterns.",
    "content": "Learn how to create beautiful, responsive widgets with great UX.\n\n## Inline Styles (Recommended)\n\n### Why Inline Styles?\n\nâœ… **Advantages:**\n\n* No build configuration needed\n* Scoped to component automatically\n* Dynamic based on props/state\n* Works in all environments\n* Simple and straightforward\n\nâŒ **No need for:**\n\n* CSS files\n* CSS modules\n* Styled-components\n* Tailwind (in most cases)\n\n## Example Widget Styling\n\n```jsx\nexport default function WeatherCard() {\n  const { city, forecast } = useWidgetProps();\n\n  return (\n    <div\n      style={{\n        padding: \"1.5rem\",\n        borderRadius: \"16px\",\n        background: \"linear-gradient(135deg, #4f46e5, #7c3aed)\",\n        color: \"white\",\n        boxShadow: \"0 20px 40px -20px rgba(79, 70, 229, 0.6)\",\n      }}\n    >\n      <p style={{ fontSize: \"0.85rem\", opacity: 0.8 }}>{city}</p>\n      <h2 style={{ margin: \"0.5rem 0\", fontSize: \"2rem\" }}>\n        {forecast.temperature}Â°\n      </h2>\n      <p>{forecast.summary}</p>\n    </div>\n  );\n}\n```\n\n## Responsive Layouts\n\n```jsx\nconst containerStyle = {\n  display: \"grid\",\n  gap: \"1rem\",\n  gridTemplateColumns: \"repeat(auto-fit, minmax(220px, 1fr))\",\n};\n```\n\n* Use CSS grid or flexbox inline\n* Prefer percentage widths or `minmax` for responsive cards\n* Adjust spacing with consistent `rem` values\n\n## Typography\n\n* Set `fontSize`, `fontWeight`, `lineHeight` inline\n* Use system fonts for consistency: `\"Inter\", -apple-system, system-ui`\n* Keep headings bold and larger than body text\n\n## Theming\n\n```jsx\nconst theme = {\n  background: \"#0f172a\",\n  surface: \"#1e293b\",\n  primary: \"#38bdf8\",\n  text: \"#e2e8f0\",\n};\n```\n\nApply theme values through inline styles or helper functions to keep widgets cohesive.\n\n## Polishing Touches\n\n* Rounded corners (`borderRadius`)\n* Soft shadows (`boxShadow`)\n* Gradient backgrounds\n* Micro interactions (hover styles, button animations)\n* Color-coded states for success/warning/error\n",
    "_searchMeta": {
      "cleanContent": "learn how to create beautiful responsive widgets with great ux inline styles recommended why inline styles advantages: no build configuration needed scoped to component automatically dynamic based on props state works in all environments simple and straightforward no need for: css files css modules styled-components tailwind in most cases example widget styling responsive layouts use css grid or flexbox inline prefer percentage widths or minmax for responsive cards adjust spacing with consistent rem values typography set fontsize fontweight lineheight inline use system fonts for consistency: inter -apple-system system-ui keep headings bold and larger than body text theming apply theme values through inline styles or helper functions to keep widgets cohesive polishing touches rounded corners borderradius soft shadows boxshadow gradient backgrounds micro interactions hover styles button animations color-coded states for success warning error",
      "headings": [
        "Inline Styles (Recommended)",
        "Example Widget Styling",
        "Responsive Layouts",
        "Typography",
        "Theming",
        "Polishing Touches"
      ],
      "keywords": [
        "Inline Styles (Recommended)",
        "Example Widget Styling",
        "Responsive Layouts",
        "Typography",
        "Theming",
        "Polishing Touches",
        "Advantages:",
        "No need for:",
        "jsx\nexport default function WeatherCard() {\n  const { city, forecast } = useWidgetProps();\n\n  return (\n    <div\n      style={{\n        padding: \"1.5rem\",\n        borderRadius: \"16px\",\n        background: \"linear-gradient(135deg, #4f46e5, #7c3aed)\",\n        color: \"white\",\n        boxShadow: \"0 20px 40px -20px rgba(79, 70, 229, 0.6)\",\n      }}\n    >\n      <p style={{ fontSize: \"0.85rem\", opacity: 0.8 }}>{city}</p>\n      <h2 style={{ margin: \"0.5rem 0\", fontSize: \"2rem\" }}>\n        {forecast.temperature}Â°\n      </h2>\n      <p>{forecast.summary}</p>\n    </div>\n  );\n}",
        "## Responsive Layouts",
        "jsx\nconst containerStyle = {\n  display: \"grid\",\n  gap: \"1rem\",\n  gridTemplateColumns: \"repeat(auto-fit, minmax(220px, 1fr))\",\n};",
        "* Use CSS grid or flexbox inline\n* Prefer percentage widths or",
        "for responsive cards\n* Adjust spacing with consistent",
        "values\n\n## Typography\n\n* Set",
        ",",
        "inline\n* Use system fonts for consistency:",
        "* Keep headings bold and larger than body text\n\n## Theming",
        "jsx\nconst theme = {\n  background: \"#0f172a\",\n  surface: \"#1e293b\",\n  primary: \"#38bdf8\",\n  text: \"#e2e8f0\",\n};",
        "Apply theme values through inline styles or helper functions to keep widgets cohesive.\n\n## Polishing Touches\n\n* Rounded corners (",
        ")\n* Soft shadows ("
      ]
    }
  },
  {
    "slug": "/tools",
    "title": "Building Tools",
    "description": "Implement Python backends that power FastApps widgets and expose inputs to ChatGPT.",
    "content": "Learn how to create Python tools that power your ChatGPT widgets.\n\n## What is a Tool?\n\nA tool is a Python class that:\n\n* Lives in `server/tools/<widget>_tool.py`\n* Extends `BaseWidget`\n* Defines inputs with Pydantic\n* Implements widget logic in `execute()`\n\n## Basic Tool Structure\n\n```python\nfrom fastapps import BaseWidget, Field, ConfigDict\nfrom pydantic import BaseModel\nfrom typing import Dict, Any\n\n# 1. Define inputs\nclass GreetingInput(BaseModel):\n    model_config = ConfigDict(populate_by_name=True)\n    name: str = Field(..., description=\"Person to greet\")\n\n# 2. Implement tool\nclass GreetingWidget(BaseWidget):\n    identifier = \"greeting\"\n    input_model = GreetingInput\n\n    def execute(self, inputs: GreetingInput) -> Dict[str, Any]:\n        return {\"message\": f\"Hello {inputs.name}!\"}\n```\n\n## Input Validation\n\n* Use `pydantic` models for automatic validation\n* Add descriptions to drive ChatGPT prompt suggestions\n* Provide defaults for optional fields\n\n## Accessing External Services\n\n```python\nimport httpx\n\nclass WeatherWidget(BaseWidget):\n    identifier = \"weather\"\n    input_model = WeatherInput\n\n    async def execute(self, inputs: WeatherInput) -> Dict[str, Any]:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                \"https://api.weatherapi.com/v1/current.json\",\n                params={\"q\": inputs.city},\n            )\n        data = response.json()\n        return {\"city\": inputs.city, \"forecast\": data[\"current\"]}\n```\n\n## Returning Data\n\n* Return dictionaries that match the props your widget expects\n* Stick to JSON-serializable data types\n* Provide friendly defaults (`[]`, `{}`, etc.) when data is missing\n\n## Best Practices\n\n* Keep business logic in the tool; keep widgets focused on presentation\n* Extract API clients or reusable logic into `server/api/`\n* Use async `execute` when calling network resources\n* Log errors and return safe fallbacks to the widget\n",
    "_searchMeta": {
      "cleanContent": "learn how to create python tools that power your chatgpt widgets what is a tool a tool is a python class that: lives in server tools widget _tool py extends basewidget defines inputs with pydantic implements widget logic in execute basic tool structure input validation use pydantic models for automatic validation add descriptions to drive chatgpt prompt suggestions provide defaults for optional fields accessing external services returning data return dictionaries that match the props your widget expects stick to json-serializable data types provide friendly defaults etc when data is missing best practices keep business logic in the tool keep widgets focused on presentation extract api clients or reusable logic into server api use async execute when calling network resources log errors and return safe fallbacks to the widget",
      "headings": [
        "What is a Tool?",
        "Basic Tool Structure",
        "Input Validation",
        "Accessing External Services",
        "Returning Data",
        "Best Practices"
      ],
      "keywords": [
        "What is a Tool?",
        "Basic Tool Structure",
        "Input Validation",
        "Accessing External Services",
        "Returning Data",
        "Best Practices",
        "server/tools/<widget>_tool.py",
        "BaseWidget",
        "execute()",
        "python\nfrom fastapps import BaseWidget, Field, ConfigDict\nfrom pydantic import BaseModel\nfrom typing import Dict, Any\n\n# 1. Define inputs\nclass GreetingInput(BaseModel):\n    model_config = ConfigDict(populate_by_name=True)\n    name: str = Field(..., description=\"Person to greet\")\n\n# 2. Implement tool\nclass GreetingWidget(BaseWidget):\n    identifier = \"greeting\"\n    input_model = GreetingInput\n\n    def execute(self, inputs: GreetingInput) -> Dict[str, Any]:\n        return {\"message\": f\"Hello {inputs.name}!\"}",
        "## Input Validation\n\n* Use",
        "models for automatic validation\n* Add descriptions to drive ChatGPT prompt suggestions\n* Provide defaults for optional fields\n\n## Accessing External Services",
        "python\nimport httpx\n\nclass WeatherWidget(BaseWidget):\n    identifier = \"weather\"\n    input_model = WeatherInput\n\n    async def execute(self, inputs: WeatherInput) -> Dict[str, Any]:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                \"https://api.weatherapi.com/v1/current.json\",\n                params={\"q\": inputs.city},\n            )\n        data = response.json()\n        return {\"city\": inputs.city, \"forecast\": data[\"current\"]}",
        "## Returning Data\n\n* Return dictionaries that match the props your widget expects\n* Stick to JSON-serializable data types\n* Provide friendly defaults (",
        ",",
        ", etc.) when data is missing\n\n## Best Practices\n\n* Keep business logic in the tool; keep widgets focused on presentation\n* Extract API clients or reusable logic into",
        "* Use async"
      ]
    }
  },
  {
    "slug": "/tutorial",
    "title": "FastApps Widget Tutorial",
    "description": "Build a complete FastApps widget step by step, from Python tool to React component.",
    "content": "Learn to build ChatGPT widgets step by step.\n\n## Tutorial 1: Hello World\n\n### Goal\n\nCreate a simple greeting widget that displays a personalized message.\n\n### Python Tool\n\nCreate `server/tools/greeting_tool.py`:\n\n```python\nfrom fastapps import BaseWidget, Field, ConfigDict\nfrom pydantic import BaseModel\nfrom typing import Dict, Any\n\nclass GreetingInput(BaseModel):\n    model_config = ConfigDict(populate_by_name=True)\n    name: str = Field(..., description=\"Person to greet\")\n\nclass GreetingWidget(BaseWidget):\n    identifier = \"greeting\"\n    input_model = GreetingInput\n\n    def execute(self, inputs: GreetingInput) -> Dict[str, Any]:\n        return {\"message\": f\"Hello {inputs.name}!\"}\n```\n\n### React Widget\n\nCreate `widgets/greeting/index.jsx`:\n\n```jsx\nimport React from \"react\";\nimport { useWidgetProps } from \"chatjs-hooks\";\n\nexport default function GreetingWidget() {\n  const props = useWidgetProps();\n  return (\n    <div style={{ padding: \"1rem\" }}>\n      <h2>Hello Widget</h2>\n      <p>{props.message}</p>\n    </div>\n  );\n}\n```\n\n### Run It\n\n```bash\nfastapps dev\n```\n\n* Auto-discovers the widget\n* Hot reloads changes\n* Launches the widget in ChatGPT preview\n\n## Tutorial 2: Pizza List\n\n### Goal\n\nDisplay dynamic pizza data fetched from a Python tool.\n\n### Python Tool\n\n```python\nfrom fastapps import BaseWidget, Field\nfrom pydantic import BaseModel\nfrom typing import Dict, Any, List\n\nclass PizzaInput(BaseModel):\n    city: str = Field(..., description=\"City to search\")\n\nclass PizzaWidget(BaseWidget):\n    identifier = \"pizza_list\"\n    input_model = PizzaInput\n\n    def execute(self, inputs: PizzaInput) -> Dict[str, Any]:\n        pizzas: List[Dict[str, str]] = fetch_pizzas(inputs.city)\n        return {\"city\": inputs.city, \"pizzas\": pizzas}\n```\n\n### React Widget\n\n```jsx\nimport React from \"react\";\nimport { useWidgetProps } from \"chatjs-hooks\";\n\nexport default function PizzaList() {\n  const { city, pizzas } = useWidgetProps();\n\n  return (\n    <div style={{ padding: \"1rem\" }}>\n      <h2>Pizza in {city}</h2>\n      <ul>\n        {pizzas.map((pizza) => (\n          <li key={pizza.name}>\n            <strong>{pizza.name}</strong> â€” {pizza.style}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n### State Updates\n\nAdd a search box with widget state:\n\n```jsx\nimport { useWidgetProps, useWidgetState } from \"chatjs-hooks\";\n\nexport default function PizzaList() {\n  const { city, pizzas } = useWidgetProps();\n  const [query, setQuery] = useWidgetState(\"query\", \"\");\n\n  const filtered = pizzas.filter((pizza) =>\n    pizza.name.toLowerCase().includes(query.toLowerCase())\n  );\n\n  return (\n    <div style={{ padding: \"1rem\" }}>\n      <input\n        value={query}\n        onChange={(event) => setQuery(event.target.value)}\n        placeholder=\"Filter pizzas\"\n      />\n      <ul>\n        {filtered.map((pizza) => (\n          <li key={pizza.name}>{pizza.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Tutorial 3: Deploy\n\n1. `fastapps build` to produce production assets\n2. Deploy Python backend to your platform of choice\n3. Serve the widget bundle to ChatGPT\n\nYou're now ready to build full-featured widgets with FastApps.\n",
    "_searchMeta": {
      "cleanContent": "learn to build chatgpt widgets step by step tutorial 1: hello world goal create a simple greeting widget that displays a personalized message python tool create server tools greeting_tool py: react widget create widgets greeting index jsx: run it auto-discovers the widget hot reloads changes launches the widget in chatgpt preview tutorial 2: pizza list goal display dynamic pizza data fetched from a python tool python tool react widget state updates add a search box with widget state: tutorial 3: deploy fastapps build to produce production assets deploy python backend to your platform of choice serve the widget bundle to chatgpt you re now ready to build full-featured widgets with fastapps",
      "headings": [
        "Tutorial 1: Hello World",
        "Tutorial 2: Pizza List",
        "Tutorial 3: Deploy"
      ],
      "keywords": [
        "Tutorial 1: Hello World",
        "Tutorial 2: Pizza List",
        "Tutorial 3: Deploy",
        "server/tools/greeting_tool.py",
        "python\nfrom fastapps import BaseWidget, Field, ConfigDict\nfrom pydantic import BaseModel\nfrom typing import Dict, Any\n\nclass GreetingInput(BaseModel):\n    model_config = ConfigDict(populate_by_name=True)\n    name: str = Field(..., description=\"Person to greet\")\n\nclass GreetingWidget(BaseWidget):\n    identifier = \"greeting\"\n    input_model = GreetingInput\n\n    def execute(self, inputs: GreetingInput) -> Dict[str, Any]:\n        return {\"message\": f\"Hello {inputs.name}!\"}",
        "### React Widget\n\nCreate",
        ":",
        "jsx\nimport React from \"react\";\nimport { useWidgetProps } from \"chatjs-hooks\";\n\nexport default function GreetingWidget() {\n  const props = useWidgetProps();\n  return (\n    <div style={{ padding: \"1rem\" }}>\n      <h2>Hello Widget</h2>\n      <p>{props.message}</p>\n    </div>\n  );\n}",
        "### Run It",
        "bash\nfastapps dev",
        "* Auto-discovers the widget\n* Hot reloads changes\n* Launches the widget in ChatGPT preview\n\n## Tutorial 2: Pizza List\n\n### Goal\n\nDisplay dynamic pizza data fetched from a Python tool.\n\n### Python Tool",
        "python\nfrom fastapps import BaseWidget, Field\nfrom pydantic import BaseModel\nfrom typing import Dict, Any, List\n\nclass PizzaInput(BaseModel):\n    city: str = Field(..., description=\"City to search\")\n\nclass PizzaWidget(BaseWidget):\n    identifier = \"pizza_list\"\n    input_model = PizzaInput\n\n    def execute(self, inputs: PizzaInput) -> Dict[str, Any]:\n        pizzas: List[Dict[str, str]] = fetch_pizzas(inputs.city)\n        return {\"city\": inputs.city, \"pizzas\": pizzas}",
        "### React Widget",
        "jsx\nimport React from \"react\";\nimport { useWidgetProps } from \"chatjs-hooks\";\n\nexport default function PizzaList() {\n  const { city, pizzas } = useWidgetProps();\n\n  return (\n    <div style={{ padding: \"1rem\" }}>\n      <h2>Pizza in {city}</h2>\n      <ul>\n        {pizzas.map((pizza) => (\n          <li key={pizza.name}>\n            <strong>{pizza.name}</strong> â€” {pizza.style}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
        "### State Updates\n\nAdd a search box with widget state:",
        "jsx\nimport { useWidgetProps, useWidgetState } from \"chatjs-hooks\";\n\nexport default function PizzaList() {\n  const { city, pizzas } = useWidgetProps();\n  const [query, setQuery] = useWidgetState(\"query\", \"\");\n\n  const filtered = pizzas.filter((pizza) =>\n    pizza.name.toLowerCase().includes(query.toLowerCase())\n  );\n\n  return (\n    <div style={{ padding: \"1rem\" }}>\n      <input\n        value={query}\n        onChange={(event) => setQuery(event.target.value)}\n        placeholder=\"Filter pizzas\"\n      />\n      <ul>\n        {filtered.map((pizza) => (\n          <li key={pizza.name}>{pizza.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
        "## Tutorial 3: Deploy\n\n1."
      ]
    }
  },
  {
    "slug": "/widgets",
    "title": "Building Widgets",
    "description": "Create interactive React components that render FastApps data inside ChatGPT.",
    "content": "Learn how to create beautiful, interactive React components for your ChatGPT widgets.\n\n## What is a Widget?\n\nA widget is a React component that:\n\n* Lives in `widgets/<widget-name>/index.jsx`\n* Receives props from your Python tool\n* Renders in the ChatGPT interface\n* Can be interactive and stateful\n\n## Basic Widget Structure\n\n```jsx\nimport React from \"react\";\nimport { useWidgetProps } from \"chatjs-hooks\";\n\nexport default function MyWidget() {\n  // 1. Get data from Python backend\n  const props = useWidgetProps();\n\n  // 2. Render UI based on props\n  return (\n    <div style={{ padding: \"1rem\" }}>\n      <h2>{props.title}</h2>\n      <p>{props.description}</p>\n    </div>\n  );\n}\n```\n\n## Pattern: Lists\n\n```jsx\nexport default function PizzaList() {\n  const { pizzas } = useWidgetProps();\n\n  return (\n    <ul>\n      {pizzas.map((pizza) => (\n        <li key={pizza.name}>\n          <strong>{pizza.name}</strong> â€” {pizza.style}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n## Pattern: User Input\n\n```jsx\nimport { useWidgetState } from \"chatjs-hooks\";\n\nexport default function TodoWidget() {\n  const [todos, setTodos] = useWidgetState(\"todos\", []);\n  const [text, setText] = useWidgetState(\"text\", \"\");\n\n  return (\n    <div>\n      <input\n        value={text}\n        onChange={(event) => setText(event.target.value)}\n        placeholder=\"Add a task\"\n      />\n      <button\n        onClick={() => {\n          setTodos([...todos, text]);\n          setText(\"\");\n        }}\n      >\n        Add\n      </button>\n      <ul>\n        {todos.map((todo) => (\n          <li key={todo}>{todo}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n## Pattern: Conditional UI\n\n```jsx\nexport default function WeatherWidget() {\n  const { loading, weather } = useWidgetProps();\n\n  if (loading) {\n    return <p>Loading...</p>;\n  }\n\n  if (!weather) {\n    return <p>No forecast available.</p>;\n  }\n\n  return (\n    <div>\n      <h2>{weather.city}</h2>\n      <p>{weather.summary}</p>\n    </div>\n  );\n}\n```\n\n## Tips\n\n* Keep components pure and deterministic\n* Use inline styles for fast iteration\n* Extract helpers into `widgets/shared/` if you reuse UI\n* Handle loading and empty states explicitly\n",
    "_searchMeta": {
      "cleanContent": "learn how to create beautiful interactive react components for your chatgpt widgets what is a widget a widget is a react component that: lives in widgets widget-name index jsx receives props from your python tool renders in the chatgpt interface can be interactive and stateful basic widget structure pattern: lists pattern: user input pattern: conditional ui tips keep components pure and deterministic use inline styles for fast iteration extract helpers into widgets shared if you reuse ui handle loading and empty states explicitly",
      "headings": [
        "What is a Widget?",
        "Basic Widget Structure",
        "Pattern: Lists",
        "Pattern: User Input",
        "Pattern: Conditional UI",
        "Tips"
      ],
      "keywords": [
        "What is a Widget?",
        "Basic Widget Structure",
        "Pattern: Lists",
        "Pattern: User Input",
        "Pattern: Conditional UI",
        "Tips",
        "widgets/<widget-name>/index.jsx",
        "jsx\nimport React from \"react\";\nimport { useWidgetProps } from \"chatjs-hooks\";\n\nexport default function MyWidget() {\n  // 1. Get data from Python backend\n  const props = useWidgetProps();\n\n  // 2. Render UI based on props\n  return (\n    <div style={{ padding: \"1rem\" }}>\n      <h2>{props.title}</h2>\n      <p>{props.description}</p>\n    </div>\n  );\n}",
        "## Pattern: Lists",
        "jsx\nexport default function PizzaList() {\n  const { pizzas } = useWidgetProps();\n\n  return (\n    <ul>\n      {pizzas.map((pizza) => (\n        <li key={pizza.name}>\n          <strong>{pizza.name}</strong> â€” {pizza.style}\n        </li>\n      ))}\n    </ul>\n  );\n}",
        "## Pattern: User Input",
        "jsx\nimport { useWidgetState } from \"chatjs-hooks\";\n\nexport default function TodoWidget() {\n  const [todos, setTodos] = useWidgetState(\"todos\", []);\n  const [text, setText] = useWidgetState(\"text\", \"\");\n\n  return (\n    <div>\n      <input\n        value={text}\n        onChange={(event) => setText(event.target.value)}\n        placeholder=\"Add a task\"\n      />\n      <button\n        onClick={() => {\n          setTodos([...todos, text]);\n          setText(\"\");\n        }}\n      >\n        Add\n      </button>\n      <ul>\n        {todos.map((todo) => (\n          <li key={todo}>{todo}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
        "## Pattern: Conditional UI",
        "jsx\nexport default function WeatherWidget() {\n  const { loading, weather } = useWidgetProps();\n\n  if (loading) {\n    return <p>Loading...</p>;\n  }\n\n  if (!weather) {\n    return <p>No forecast available.</p>;\n  }\n\n  return (\n    <div>\n      <h2>{weather.city}</h2>\n      <p>{weather.summary}</p>\n    </div>\n  );\n}",
        "## Tips\n\n* Keep components pure and deterministic\n* Use inline styles for fast iteration\n* Extract helpers into"
      ]
    }
  }
]